#include <algorithm>
#include <format>
#include <fstream>
#include "grammar.h"
#include "rd_codegen.h"

//------------------------------------------//
// Recursive Descent Parser Code Generation //
//------------------------------------------//

/* Code that starts parser file
 * Token storage, parse tree classes and printing, error handling, terminal parsing
 * sentence holds the tokens generated by the lexer
 * pos, start and end keep track of parser position in input */
static std::string beginningCode = R"(#include <iostream>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <vector>

std::string makeIndent(int depth) {
    std::string indent = "";
    while (depth > 0) {
        indent += "|   ";
        depth--;
    }
    return indent;
}

struct TOKEN {
    std::string str;
    int lineNo, columnNo;
};

TOKEN makeToken(std::string str, int lineNo, int columnNo) {
    TOKEN token;
    token.str = str;
    token.lineNo = lineNo;
    token.columnNo = columnNo - str.length() + 1;
    return token;
}

std::string displayPos(int lineNo, int columnNo) {
    if (lineNo == 0)
        return " [end]";
    return " [ln " + std::to_string(lineNo) + ", col " + std::to_string(columnNo) + "]";
}

class ParseNode {
    public:
        virtual ~ParseNode() {}
        virtual std::string toString(int depth) {return "";};
};

using PNode = std::shared_ptr<ParseNode>;
using PNodeList = std::vector<PNode>;

class Leaf: public ParseNode {
    TOKEN Symbol;

    public:
        Leaf(TOKEN s): Symbol(s) {}
        std::string toString(int depth) override {
            return makeIndent(depth) + "TERMINAL" + displayPos(Symbol.lineNo, Symbol.columnNo) + ": " + Symbol.str + "\n";
        }
};

class Internal: public ParseNode {
    std::string Symbol;
    std::vector<PNodeList> Children;

    public:
        Internal(std::string s, std::vector<PNodeList> c): Symbol(s), Children(std::move(c)) {}
        std::string toString(int depth) override {
            std::string result = makeIndent(depth) + "NON-TERMINAL: " + Symbol;
            if (Children.empty())
                return result += " [EPSILON]\n";
            result += "\n";
            for (const auto& conjNodes : Children) {
                result += makeIndent(depth + 1) + "CONJUNCT\n";
                for (const PNode& n : conjNodes) {
                    if (n)
                        result += n->toString(depth + 2);
                }
            }
            return result;
        }
};

FILE *inputFile;
std::vector<TOKEN> sentence;
size_t pos, start, end;

void tokenFail(bool wanted, std::string wrong, std::string expected) {
    if (!wanted)
        return;

    std::string failPos = displayPos(sentence[pos].lineNo, sentence[pos].columnNo);
    std::string failStr = (wrong == "") ? "EOF" : wrong;
    std::cout << "Parser error" + failPos + ": unexpected sequence " + failStr + ", expecting " + expected + "\n";
}

void conjFail(bool wanted, size_t start, size_t end, bool posConj, std::string conjStr) {
    if (!wanted)
        return;

    std::string currentPos = displayPos(sentence[pos-1].lineNo, sentence[pos-1].columnNo);
    std::string startPos = displayPos(sentence[start].lineNo, sentence[start].columnNo);
    std::string report = "Parser error" + currentPos + ": parsing of conjunct" + conjStr + " starting at" + startPos;

    if (posConj)
        std::cout << report + " should end at" + displayPos(sentence[end-1].lineNo, sentence[end-1].columnNo) + "\n";
    else
        std::cout << report + " is unwanted\n";
}

PNode terminal(bool wanted, std::string tokenStr) {
    if (sentence[pos].str == tokenStr)
        return std::make_shared<Leaf>(sentence[pos++]);

    tokenFail(wanted, sentence[pos].str, tokenStr);
    return nullptr;
}

bool startsWith(std::string str, std::string prefix) {
    return (str.compare(0, prefix.length(), prefix) == 0);
}

std::map<std::pair<std::string, size_t>, PNode> memo;)";

// Assign a number to each non-terminal
static std::map<std::string, int> nonTerminalNos;

// Generate code for parsing a sequence of symbols
static std::string parseSymbSeq(const SymbVec& symbols, bool posConj, size_t conjNo) {
    std::string symbolSequence = "";

    int symbNo = 0;
    for (const SYMBOL& symb : symbols) {
        std::string symbFunction = "";
        if (symb.type != EPSILON) {
            std::string wantedStr = "wanted";
            if (!posConj)
                wantedStr = "!wanted";
            if (symb.type == LITERAL)
                symbFunction += "terminal(" + wantedStr + ", \"" + symb.str + "\"" + ")";
            else
                symbFunction += "nonTerminal" + std::to_string(nonTerminalNos[symb.str]) +"(" + wantedStr + ")";
        }

        if (symbFunction != "") {

            // If conjunct is negative, check if any symbol function has failed
            if (!posConj) {
                if (symbNo > 0)
                    symbolSequence += " && ";
                symbolSequence += symbFunction;

            /* If conjunct is positive, add a node for each symbol to the conjunct subtree
             * If one symbol function fails, whole conjunct fails */
            } else {
                std::string symbNode = std::format("conj{}node{}", conjNo, symbNo);
                symbolSequence += std::format(
R"(    PNode {} = {};
    if (!{})
        return nullptr;
    conj{}.push_back({});
)",
                symbNode, symbFunction, symbNode, conjNo, symbNode);
            }
        }
        symbNo++;
    }
    return symbolSequence;
}

// Generate code for parsing a conjunct
static std::string parseConj(const GNode& conj, size_t conjNo, size_t ruleSize) {
    bool posConj = conj->isPositive();
    std::string conjCode = "";
    const SymbVec& conjSymbols = conj->getSymbols();
    std::string symbolSequence = parseSymbSeq(conjSymbols, posConj, conjNo);

    std::string conjStr = "";
    for (const SYMBOL& symb : conjSymbols)
        conjStr += " " + symb.str;

    // Negative conjunct
    if (!posConj) {
        std::string isLastConj = "";

        // After last negative conjunct, move to end of substring
        if (conjNo == ruleSize - 1)
            isLastConj = "\n    pos = end;";

        // If negative conjunct is successfully parsed, this is a failure
        return std::format(R"(
    pos = start;
    bool success = ({});
    if (success && (pos == end)) {{
        conjFail(wanted, start, end, false, "{}");
        return nullptr;
    }}{}
)", 
        symbolSequence, conjStr, isLastConj);
    }
    
    // Positive conjunct that contains at least 1 (non-)terminal
    if (posConj && (symbolSequence != "")) {
        conjCode = std::format(
R"(    PNodeList conj{};
{}
)",
        conjNo, symbolSequence); // create new subtree version for conjunct

        // Adjust code if rule contains multiple conjuncts
        if (ruleSize > 1) {
            if (conjNo == 0)
                conjCode = std::format(
R"(    start = pos;
{}    end = pos;
)", 
                conjCode); // Record positions where first conjunct starts and ends

            /* For subsequent conjuncts, return to recorded start position before parsing
             * If parsing stops before or after recorded end position, this is a failure,
             * since a different substring of the input has been parsed */
            else
                conjCode = std::format(R"(
    pos = start;{}
    if (pos != end) {{
        conjFail(wanted, start, end, true, "{}");
        return nullptr;
    }}
)",
                conjCode, conjStr);
        }

        return std::format(
R"({}    subTreeVersions.push_back(conj{});

)",
        conjCode, conjNo); // add to subtree versions for this non-terminal
    }

    return conjCode;
}

static std::string parseRule(int ruleNo, const GNodeList& conjuncts) {
    std::string parseConjuncts = "";
    size_t ruleSize = conjuncts.size(); // number of conjuncts in rule

    // Generate code for each conjunct
    size_t conjNo = 0;
    for (const GNode& conj : conjuncts) {
        parseConjuncts += parseConj(conj, conjNo, ruleSize);
        conjNo++;
    }

    // Add conjunct code to function
    return std::format(
R"(

PNode rule{}(bool wanted, std::string nt) {{
    std::vector<PNodeList> subTreeVersions;
{}    return std::make_shared<Internal>(nt, std::move(subTreeVersions));
}})", 
    ruleNo, parseConjuncts); // if return statement is reached, parsing is successful
}

// Generate code for parsing a non-terminal
static std::string parseNonTerminal(int nonTerminalNo, const std::string& nt) {
    std::string ntCases = "";
    std::string expected = "";
    std::vector<std::string> sequences;

    // For each sequence that is paired with the non-terminal in the parse table, add a case
    for (const auto& entry : parseTable) {
        if ((entry.first).first == nt)
            sequences.push_back((entry.first).second); // sequence
    }
    std::sort(sequences.begin(), sequences.end(), [](std::string& a, std::string& b) {
        return a.length() > b.length();
    }); // sort sequences in descending order of length

    int caseNo = 0;
    for (std::string s : sequences) {
        int ruleNo = parseTable[make_pair(nt, s)];
        std::string elseStr = "";
        if (caseNo > 0)
            elseStr = "} else ";

        // Add code for which rule to use in this case
        ntCases += std::format(
R"(
        {}if (startsWith(nextKTokens, "{}")) {{
            newNode = std::move(rule{}(wanted, "{}"));
)", 
        elseStr, s, ruleNo, nt);

        // Add sequence to list of expected sequences
        std::string displayS = (s == "") ? "EOF" : s;
        expected = (expected == "") ? expected += displayS : expected += ", " + displayS;
        caseNo++;
    }

    // Add cases to the non-terminal's numbered function
    return std::format(R"(

PNode nonTerminal{}(bool wanted) {{
    std::pair<std::string, size_t> memoIndex = std::make_pair("{}", pos);

    if (memo.count(memoIndex) == 0) {{
        std::string nextKTokens = nextK();
        PNode newNode;
{}
        }} else {{
            tokenFail(wanted, nextKTokens, "{}");
            newNode = nullptr;
        }}

        memo[memoIndex] = newNode;
        return newNode;
    }}

    if (!memo[memoIndex])
        return nullptr;
    return memo[memoIndex];
}})", 
    nonTerminalNo, nt, ntCases, expected); // if function does not return after any case, parsing fails
}

/* Main parser function
 * Lexer: reads characters from input file and converts them to tokens
 * Calls the parsing function for the start symbol (the last numbered non-terminal)
 * Parser must stop at the end of the input for parsing to succeed
 * If parsing succeeds, print parse tree */
static std::string mainFunction(int nonTerminalNo, std::string terminalSet) {
    return std::format(R"(

int main(int argc, char **argv) {{
    if (argc == 2) {{
        inputFile = fopen(argv[1], "r");
        if (inputFile == NULL)
            std::cout << "Error opening file\n";
    }} else {{
        std::cout << "Usage: ./parser <input file>\n";
        return 1;
    }}

    std::set<std::string> terminals = {};
    
    int maxTermLen = 0;
    for (std::string str : terminals)
        maxTermLen = (maxTermLen > str.length()) ? maxTermLen : str.length();

    std::string currentStr = "";
    int lineNo = 1;
    int columnNo = 1;
    int maxMatchLen = 0;
    char currentChar = fgetc(inputFile);
    while (currentChar != EOF) {{
        bool newLine = false;
        if ((currentChar == '\n') || (currentChar == '\r')) {{
            char nextChar;
            if ((nextChar = fgetc(inputFile)) != EOF)
                currentStr += currentChar;
            currentChar = nextChar;
            newLine = true;
        }} else {{
            currentStr += currentChar;
            currentChar = fgetc(inputFile);
        }}

        if (terminals.count(currentStr) > 0)
            maxMatchLen = currentStr.length();

        if (currentStr.length() == maxTermLen) {{
            if (maxMatchLen == 0) {{
                std::cout << "Lexer error [ln " + std::to_string(lineNo) + ", col " + std::to_string(columnNo - currentStr.length() + 1) + "]: unrecognised sequence '" + currentStr + "'\n";
                return 1;
            }}

            std::string tokenStr = currentStr.substr(0, maxMatchLen);
            sentence.push_back(makeToken(tokenStr, lineNo, columnNo));
            currentStr.erase(0, maxMatchLen);
            maxMatchLen = 0;
        }}

        columnNo++;
        if (newLine) {{
            lineNo++;
            columnNo = 1;
        }}
    }}
    fclose(inputFile);

    if (sentence.empty()) {{
        std::cout << "File is empty\n";
        return 1;
    }}

    pos = 0;
    PNode root = nonTerminal{}(true);
    if (root) {{
        if (pos == sentence.size()) {{
            std::cout << "Parsing successful\n";
            std::cout << root->toString(0);
            return 0;
        }}

        std::cout << "Parser error" + displayPos(sentence[pos].lineNo, sentence[pos].columnNo) + ": parsing terminated before end of input\n";
    }}

    std::cout << "Parsing failed\n";
    return 1;
}})", 
    terminalSet, nonTerminalNo);
}

// Write code to file
void RDCodegen(StrVec ntOrder, int k) {
    std::ofstream parserFile;
    parserFile.open("parser.cpp");
    parserFile << beginningCode;

    // Function for obtaining sequence of next k tokens
    parserFile << std::format(R"(

std::string nextK() {{
    std::string sequence = "";
    int i = pos;
    while ((i < sentence.size()) && (i < pos + {})) {{
        sequence += sentence[i].str;
        i++;
    }}
    return sequence;
}})",
    k);

    // Build string representing set of terminals
    std::string terminalSet = "{";
    int terminalNo = 0;
    for (const std::string& s : alphabet) {
        if (terminalNo > 0)
            terminalSet += ", ";
        terminalSet += "\"" + s + "\"";
        terminalNo++;
    }
    terminalSet += "}";

    /* Assign numbers to non-terminals
     * Write forward declarations for non-terminal functions, so they can be called by
     * rule functions */
    int nonTerminalNo = 0;
    parserFile << "\n";
    for (const std::string& nt : ntOrder) {
        nonTerminalNos[nt] = nonTerminalNo;
        parserFile << "\nPNode nonTerminal" + std::to_string(nonTerminalNo) + "(bool wanted);";
        nonTerminalNo++;
    }

    // Write parser functions for rules and non-terminals
    for (const auto& ruleEntry : rules)
        parserFile << parseRule(ruleEntry.first, ruleEntry.second);
    for (const std::string& nt : ntOrder)
        parserFile << parseNonTerminal(nonTerminalNos[nt], nt);

    parserFile << mainFunction(nonTerminalNo - 1, terminalSet); // write main function
    parserFile.close();
}
